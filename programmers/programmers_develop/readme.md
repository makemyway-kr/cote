<h2>문제 명세간단 정리</h2><br>

<b>각 기능의 현재 개발 정도(퍼센티지)와 1일에 진행되는 속도가 주어진다.</b>
여기서 <b>한번의 배포 당 몇개의 기능씩 배포되는지를</b>구해내면 된다.<br>

단 여기서 앞의 기능들이 배포된 상태여야 배포할 수 있다.(ex 3번 기능이면, 1번/2번 기능이 모두 배포된 상태여야 배포 가능하다)<br>
1번 기능이 4일걸리고 , 2번기능이 2일 걸리고, 3번 기능이 1일 걸린다하면, 4일째에 1/2/3번 기능을 모두 배포할 수 있으니 답은 [3]뭐 이런식으로 나오게 된다.<br>
<p>
이 문제를 풀기 위해 첫번째로 해주어야 할 것은 <b>각 기능이 개발 완료 되기까지 걸리는 시간</b>이다.<br>
각 기능의 현재 진행도를 100에서 빼준 뒤, speed로 나누어주면 개발 완료까지 걸리는 시간을 구할 수 있다.<br>
나는 이것을 다른 배열 times에 저장해 주었다.<br>
</p>

<p>
<h3>알고리즘의 처리과정</h3>
1번기능부터 끝까지 개발에 걸리는 시간을 배열로 정리해주었다.
자 그럼 이제 무엇을 해주어야할까? <br>
간단하다. 1번 기능부터 차례차례 돌면서 1번기능보다 시간이 오래걸리는 기능을 찾고, 그 이전 까지의 기능을 배포한다.<br>
예를들어 times배열이 [5,1,3,6,1,1,3]이라 해보자.<br>
이때 5일차에 1번 기능이 개발 완료된 시점에 2번,3번기능은 개발이 완료되어있다. 기다리던중 이제 1번 기능이 개발 완료되었으니 1,2,3번 기능은 배포할 수 있다.<br>
하지만 1일차에 개발되기는 마찬가지였던 5번,6번 기능은 안타깝지만 4번기능이 완료되지 않았음으로 배포되지 못한다.<br>

<br>
이걸 위해서 배포해야할 남은 기능의 수를 저장하는  remaining변수를 만들어주었고, 남은 기능의 수(remaining)이 0이 될때까지 while문은 계속된다.<br>
그리고 남은 기능중 제일 앞의 기능(size-remaining 을 이용하여 index번호를 특정할 수 있다)과 그 다음 기능을 for문으로 비교해나가면서<br>
이보다 시간이 적게 걸리면 count를 올려준다.(count는 이번에 배포 될 기능의 수)<br>
이러다가 아직 개발완료 안된 기능을 만나면 break시켜주고, count를 answer에 push해주며 remaining도 갱신해준다.<br>
