<h2>프로그래머스 월간 코드챌린지 2 (2021)</h2><br>
<br>
<h4>sum_num.py</h4><br>
숫자를 담은 list와 부호를 담은 list가 주어지며, 부호와 숫자를 적용해 각 숫자의 합을 구하면 된다,<br>
<b>난이도 하</b><br>
<br>
<h4>absolute_sign.py</h4>
괄호로 이루어진 문자열이 주어지는데, () / {} /[] 이런식으로 짝이 지어져 있으면 absolute라 한다.<br>
이 문장을 왼쪽으로 계속 하나씩 밀었을 때, absolute가 몇번 나오는지 구해내면된다.<br>
이 문제의 solution은 문자열을 하나씩 밀어서 만든 새로운 문자열을 return 하는 rotate함수와<br>
완벽한지를 판단하는 if_right함수로 구성하였다.<br>
if_right함수는 대괄호/중괄호/소괄호 2차원 배열을 만들어서, 각 배열의 0번 소배열은 왼쪽 괄호 "( / { / [ "

가 나오는 위치를,<br>
1번 배열은 오른쪽 괄호의 위치를 저장토록 하여, 만약 왼쪽 괄호와 오른쪽 괄호의 갯수가 일치하지않거나, 오른쪽 괄호가 왼쪽 괄호보다 먼저 나오면<br>
absolute하지 않은 것으로 판단하도록 하였다. ex )   } ( ) {이면 완벽하지 않음. <br>
이후 이 함수의 실행 결과를 바탕으로 answer값을 +=1할지 말지를 결정한다(absolute이면 _+1)<br>
solution함수에서는 문자열의 길이 만큼 rotate시켜가며 if_right함수를 실행한다.<br>

난이도 중<br>
<br>
<br>
<br>
<h4>zero_tree.py</h4>
이 문제는 음의값과 양의값이 적혀있는 tree가 주어졌을때, 가장 적은 비용을 들이면서 tree의 모든 노드의 값을 0으로 만드는지에 관한 문제였다.<br>
만약 -5의값과 5의 값을 가진 노드가 인접해있으면, 5번의 과정으로 두 노드를 0으로 만들 수 있다. (-5의 값을 -1씩 5의 값을 가진 노드로 옮김)<br>
난이도 상. 풀던중 시간이 끝났다. 미해결상태.
